package transcoder

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
)

// SceneDetectionOptions holds options for scene detection
type SceneDetectionOptions struct {
	InputPath    string
	OutputDir    string
	Threshold    float64 // Scene change detection threshold (0.0 to 1.0)
	MinSceneDuration float64 // Minimum scene duration in seconds
	MaxScenes    int     // Maximum number of scenes to detect
}

// SceneInfo represents information about a detected scene
type SceneInfo struct {
	SceneNumber int     `json:"scene_number"`
	StartTime   float64 `json:"start_time"`
	EndTime     float64 `json:"end_time"`
	Duration    float64 `json:"duration"`
	FramePath   string  `json:"frame_path"` // Path to representative frame
}

// SceneDetectionResult holds the results of scene detection
type SceneDetectionResult struct {
	TotalScenes int         `json:"total_scenes"`
	Scenes      []SceneInfo `json:"scenes"`
	BestScene   *SceneInfo  `json:"best_scene"` // Most visually interesting scene
}

// DetectScenes uses FFmpeg's scene detection to identify scene changes
func (f *FFmpeg) DetectScenes(ctx context.Context, opts SceneDetectionOptions) (*SceneDetectionResult, error) {
	// Set defaults
	if opts.Threshold == 0 {
		opts.Threshold = 0.4 // Default threshold
	}
	if opts.MinSceneDuration == 0 {
		opts.MinSceneDuration = 1.0 // 1 second minimum
	}
	if opts.MaxScenes == 0 {
		opts.MaxScenes = 20 // Maximum 20 scenes
	}

	// Create output directory
	if err := os.MkdirAll(opts.OutputDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create output directory: %w", err)
	}

	// First pass: Detect scene changes using select filter
	sceneFile := filepath.Join(opts.OutputDir, "scenes.txt")

	// Use FFmpeg's scene detection filter
	// The select filter detects scene changes based on pixel differences
	args := []string{
		"-i", opts.InputPath,
		"-vf", fmt.Sprintf("select='gt(scene,%f)',metadata=print:file=%s", opts.Threshold, sceneFile),
		"-vsync", "vfr",
		"-f", "null",
		"-",
	}

	cmd := exec.CommandContext(ctx, f.ffmpegPath, args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("scene detection failed: %w, output: %s", err, string(output))
	}

	// Parse scene timestamps from metadata file
	scenes, err := parseSceneFile(sceneFile)
	if err != nil {
		return nil, fmt.Errorf("failed to parse scene file: %w", err)
	}

	// Limit number of scenes
	if len(scenes) > opts.MaxScenes {
		scenes = scenes[:opts.MaxScenes]
	}

	// Extract representative frames for each scene
	for i := range scenes {
		// Use middle of the scene as representative frame
		timestamp := scenes[i].StartTime + (scenes[i].Duration / 2)
		framePath := filepath.Join(opts.OutputDir, fmt.Sprintf("scene_%03d.jpg", i))

		if err := f.extractFrameAtTimestamp(ctx, opts.InputPath, timestamp, framePath); err != nil {
			// Log error but continue with other scenes
			continue
		}

		scenes[i].FramePath = framePath
	}

	// Select best scene (for now, use the longest scene as it's often most stable)
	bestScene := selectBestScene(scenes)

	result := &SceneDetectionResult{
		TotalScenes: len(scenes),
		Scenes:      scenes,
		BestScene:   bestScene,
	}

	return result, nil
}

// extractFrameAtTimestamp extracts a single frame at the specified timestamp
func (f *FFmpeg) extractFrameAtTimestamp(ctx context.Context, inputPath string, timestamp float64, outputPath string) error {
	args := []string{
		"-ss", fmt.Sprintf("%.2f", timestamp),
		"-i", inputPath,
		"-frames:v", "1",
		"-q:v", "2", // High quality
		"-y",
		outputPath,
	}

	cmd := exec.CommandContext(ctx, f.ffmpegPath, args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("frame extraction failed: %w, output: %s", err, string(output))
	}

	return nil
}

// parseSceneFile parses the scene metadata file generated by FFmpeg
func parseSceneFile(filepath string) ([]SceneInfo, error) {
	data, err := os.ReadFile(filepath)
	if err != nil {
		return nil, err
	}

	lines := strings.Split(string(data), "\n")
	var scenes []SceneInfo
	var prevTime float64 = 0
	sceneNum := 0

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		// Parse timestamp from metadata line
		// Format: frame:123 pts:456 pts_time:1.234
		if strings.Contains(line, "pts_time:") {
			parts := strings.Split(line, "pts_time:")
			if len(parts) < 2 {
				continue
			}

			timeStr := strings.TrimSpace(parts[1])
			timestamp, err := strconv.ParseFloat(timeStr, 64)
			if err != nil {
				continue
			}

			// Create scene from previous timestamp to current
			if sceneNum > 0 {
				scene := SceneInfo{
					SceneNumber: sceneNum,
					StartTime:   prevTime,
					EndTime:     timestamp,
					Duration:    timestamp - prevTime,
				}
				scenes = append(scenes, scene)
			}

			sceneNum++
			prevTime = timestamp
		}
	}

	return scenes, nil
}

// selectBestScene selects the most visually interesting scene
// For now, we use a simple heuristic: the longest scene, as it tends to be more stable
// In the future, this could use ML-based scoring for visual interest
func selectBestScene(scenes []SceneInfo) *SceneInfo {
	if len(scenes) == 0 {
		return nil
	}

	bestIdx := 0
	maxDuration := scenes[0].Duration

	for i, scene := range scenes {
		if scene.Duration > maxDuration {
			maxDuration = scene.Duration
			bestIdx = i
		}
	}

	return &scenes[bestIdx]
}

// GenerateIntelligentThumbnails generates thumbnails using scene detection
// This is more intelligent than uniform sampling as it picks visually distinct scenes
func (f *FFmpeg) GenerateIntelligentThumbnails(ctx context.Context, inputPath, outputDir string, count int) ([]string, error) {
	// Detect scenes
	sceneOpts := SceneDetectionOptions{
		InputPath:   inputPath,
		OutputDir:   outputDir,
		Threshold:   0.4,
		MaxScenes:   count * 2, // Detect more scenes than needed for better selection
	}

	result, err := f.DetectScenes(ctx, sceneOpts)
	if err != nil {
		return nil, fmt.Errorf("scene detection failed: %w", err)
	}

	// If we have fewer scenes than requested, fall back to uniform sampling
	if len(result.Scenes) < count {
		return f.generateUniformThumbnails(ctx, inputPath, outputDir, count)
	}

	// Select evenly distributed scenes from detected scenes
	thumbnails := make([]string, 0, count)
	step := len(result.Scenes) / count

	for i := 0; i < count; i++ {
		idx := i * step
		if idx >= len(result.Scenes) {
			idx = len(result.Scenes) - 1
		}

		if result.Scenes[idx].FramePath != "" {
			thumbnails = append(thumbnails, result.Scenes[idx].FramePath)
		}
	}

	return thumbnails, nil
}

// generateUniformThumbnails generates thumbnails at uniform intervals
func (f *FFmpeg) generateUniformThumbnails(ctx context.Context, inputPath, outputDir string, count int) ([]string, error) {
	// Get video duration
	info, err := f.ExtractVideoInfo(ctx, inputPath)
	if err != nil {
		return nil, err
	}

	interval := info.Duration / float64(count+1)
	thumbnails := make([]string, 0, count)

	for i := 1; i <= count; i++ {
		timestamp := float64(i) * interval
		framePath := filepath.Join(outputDir, fmt.Sprintf("thumbnail_%03d.jpg", i))

		if err := f.extractFrameAtTimestamp(ctx, inputPath, timestamp, framePath); err != nil {
			continue
		}

		thumbnails = append(thumbnails, framePath)
	}

	return thumbnails, nil
}
